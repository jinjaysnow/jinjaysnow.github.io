<!doctype html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="date" content="2016-04">
<meta name="keywords" content="光线追踪,ray trace,javascript">
<meta name="author" content="Jin Jay">
<meta name="description" content="计算机图形学课程作业，光线追踪模拟。"><style>
</style><style>.codehilite pre .hll { background-color: #ffffcc }
.codehilite pre  { background: #f0f3f3; }
.codehilite pre .c { color: #0099FF; font-style: italic } /* Comment */
.codehilite pre .err { color: #AA0000; background-color: #FFAAAA } /* Error */
.codehilite pre .k { color: #006699; font-weight: bold } /* Keyword */
.codehilite pre .o { color: #555555 } /* Operator */
.codehilite pre .ch { color: #0099FF; font-style: italic } /* Comment.Hashbang */
.codehilite pre .cm { color: #0099FF; font-style: italic } /* Comment.Multiline */
.codehilite pre .cp { color: #009999 } /* Comment.Preproc */
.codehilite pre .cpf { color: #0099FF; font-style: italic } /* Comment.PreprocFile */
.codehilite pre .c1 { color: #0099FF; font-style: italic } /* Comment.Single */
.codehilite pre .cs { color: #0099FF; font-weight: bold; font-style: italic } /* Comment.Special */
.codehilite pre .gd { background-color: #FFCCCC; border: 1px solid #CC0000 } /* Generic.Deleted */
.codehilite pre .ge { font-style: italic } /* Generic.Emph */
.codehilite pre .gr { color: #FF0000 } /* Generic.Error */
.codehilite pre .gh { color: #003300; font-weight: bold } /* Generic.Heading */
.codehilite pre .gi { background-color: #CCFFCC; border: 1px solid #00CC00 } /* Generic.Inserted */
.codehilite pre .go { color: #AAAAAA } /* Generic.Output */
.codehilite pre .gp { color: #000099; font-weight: bold } /* Generic.Prompt */
.codehilite pre .gs { font-weight: bold } /* Generic.Strong */
.codehilite pre .gu { color: #003300; font-weight: bold } /* Generic.Subheading */
.codehilite pre .gt { color: #99CC66 } /* Generic.Traceback */
.codehilite pre .kc { color: #006699; font-weight: bold } /* Keyword.Constant */
.codehilite pre .kd { color: #006699; font-weight: bold } /* Keyword.Declaration */
.codehilite pre .kn { color: #006699; font-weight: bold } /* Keyword.Namespace */
.codehilite pre .kp { color: #006699 } /* Keyword.Pseudo */
.codehilite pre .kr { color: #006699; font-weight: bold } /* Keyword.Reserved */
.codehilite pre .kt { color: #007788; font-weight: bold } /* Keyword.Type */
.codehilite pre .m { color: #FF6600 } /* Literal.Number */
.codehilite pre .s { color: #CC3300 } /* Literal.String */
.codehilite pre .na { color: #330099 } /* Name.Attribute */
.codehilite pre .nb { color: #336666 } /* Name.Builtin */
.codehilite pre .nc { color: #00AA88; font-weight: bold } /* Name.Class */
.codehilite pre .no { color: #336600 } /* Name.Constant */
.codehilite pre .nd { color: #9999FF } /* Name.Decorator */
.codehilite pre .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite pre .ne { color: #CC0000; font-weight: bold } /* Name.Exception */
.codehilite pre .nf { color: #CC00FF } /* Name.Function */
.codehilite pre .nl { color: #9999FF } /* Name.Label */
.codehilite pre .nn { color: #00CCFF; font-weight: bold } /* Name.Namespace */
.codehilite pre .nt { color: #330099; font-weight: bold } /* Name.Tag */
.codehilite pre .nv { color: #003333 } /* Name.Variable */
.codehilite pre .ow { color: #000000; font-weight: bold } /* Operator.Word */
.codehilite pre .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite pre .mb { color: #FF6600 } /* Literal.Number.Bin */
.codehilite pre .mf { color: #FF6600 } /* Literal.Number.Float */
.codehilite pre .mh { color: #FF6600 } /* Literal.Number.Hex */
.codehilite pre .mi { color: #FF6600 } /* Literal.Number.Integer */
.codehilite pre .mo { color: #FF6600 } /* Literal.Number.Oct */
.codehilite pre .sa { color: #CC3300 } /* Literal.String.Affix */
.codehilite pre .sb { color: #CC3300 } /* Literal.String.Backtick */
.codehilite pre .sc { color: #CC3300 } /* Literal.String.Char */
.codehilite pre .dl { color: #CC3300 } /* Literal.String.Delimiter */
.codehilite pre .sd { color: #CC3300; font-style: italic } /* Literal.String.Doc */
.codehilite pre .s2 { color: #CC3300 } /* Literal.String.Double */
.codehilite pre .se { color: #CC3300; font-weight: bold } /* Literal.String.Escape */
.codehilite pre .sh { color: #CC3300 } /* Literal.String.Heredoc */
.codehilite pre .si { color: #AA0000 } /* Literal.String.Interpol */
.codehilite pre .sx { color: #CC3300 } /* Literal.String.Other */
.codehilite pre .sr { color: #33AAAA } /* Literal.String.Regex */
.codehilite pre .s1 { color: #CC3300 } /* Literal.String.Single */
.codehilite pre .ss { color: #FFCC33 } /* Literal.String.Symbol */
.codehilite pre .bp { color: #336666 } /* Name.Builtin.Pseudo */
.codehilite pre .fm { color: #CC00FF } /* Name.Function.Magic */
.codehilite pre .vc { color: #003333 } /* Name.Variable.Class */
.codehilite pre .vg { color: #003333 } /* Name.Variable.Global */
.codehilite pre .vi { color: #003333 } /* Name.Variable.Instance */
.codehilite pre .vm { color: #003333 } /* Name.Variable.Magic */
.codehilite pre .il { color: #FF6600 } /* Literal.Number.Integer.Long */</style><script type="text/javascript" src="http://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
MathJax.Hub.Config({
  config: ["MMLorHTML.js"],
  extensions: ["tex2jax.js"],
  jax: ["input/TeX"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    processEscapes: false
  },
  TeX: {
    extensions: ["AMSmath.js", "AMSsymbols.js"],
    TagSide: "right",
    TagIndent: ".8em",
    MultLineWidth: "85%",
    equationNumbers: {
      autoNumber: "AMS",
    },
    unicode: {
      fonts: "STIXGeneral,'Arial Unicode MS'"
    }
  },
  showProcessingMessages: false
});
</script>
<title>光线追踪</title>
    <meta name="robots" content="all" />
    <!-- TODO: 移动设备配置 -->
    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="icon" sizes="192x192" href="../../images/snow.jpg">
    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="JinJay">
    <link rel="apple-touch-icon-precomposed" href="../../images/snow.jpg">
    <!-- Tile icon for Win8 (144x144 + tile color) -->
    <meta name="msapplication-TileImage" content="../../images/snow.jpg">
    <meta name="msapplication-TileColor" content="#3372DF">
    <!-- save to local storage -->
    <link href="../../mdl/icon.css" rel="stylesheet">
    <link href="http://cdn.bootcss.com/material-design-icons/3.0.1/iconfont/material-icons.min.css" rel="stylesheet">
    <!-- random generate color -->
    <link rel="stylesheet" href="../../mdl/material.red-blue.min.css" />
    <!-- template.css -->
    <link rel="stylesheet" type="text/css" href="../../stylesheets/t.css">
    <script src="../../mdl/material.min.js"></script>
  </head>
  <body>
    <!-- Uses a header that contracts as the page scrolls down. -->
    <style>
    .waterfall-demo-header-nav .mdl-navigation__link:last-of-type {
    padding-right: 0;
    }
    }
    </style>
    <div class="mdl-layout mdl-layout--fixed-header mdl-js-layout mdl-layout--overlay-drawer-button">
      <header class="mdl-layout__header mdl-layout__header--waterfall">
        <!-- Top row, always visible -->
        <div class="mdl-layout__header-row">
          <!-- TOC -->
          <span class="mdl-layout-title">目录</span>
          <div class="mdl-layout-spacer"></div>
          <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable
            mdl-textfield--floating-label mdl-textfield--align-right">
            <label class="mdl-button mdl-js-button mdl-button--icon" for="waterfall-exp">
              <i class="material-icons">search</i>
            </label>
            <div class="mdl-textfield__expandable-holder">
              <input class="mdl-textfield__input" type="text" name="sample" id="waterfall-exp" placeholder="暂不可用" />
            </div>
          </div>
        </div>
        <!-- Bottom row, not visible on scroll -->
        <div class="mdl-layout__header-row">
          <span class="mdl-layout-tile mdl-layout--large-screen-only">朝着梦想，一步一步！</span>
          <div class="mdl-layout-spacer"></div>
          <!-- Navigation -->
          <nav class="waterfall-demo-header-nav mdl-navigation">
            <a class="mdl-navigation__link" href="http://ijinjay.github.io">主页</a>
            <a class="mdl-navigation__link" href="http://ijinjay.github.io/blog/">博客</a>
            <a class="mdl-navigation__link" href="http://ijinjay.github.io/about.html">关于我</a>
          </nav>
        </div>
      </header>
      <div class="mdl-layout__drawer">
        <span class="mdl-layout-title">目录</span>
        <nav class="mdl-navigation">
          <div class="toc">
<ul>
<li><a href="#_1">架构设计</a><ul>
<li><a href="#view">View类设计</a></li>
<li><a href="#camera">Camera设计</a></li>
<li><a href="#scene">Scene设计</a></li>
<li><a href="#light">Light设计</a></li>
<li><a href="#solid">Solid设计</a></li>
</ul>
</li>
<li><a href="#_2">详细设计</a><ul>
<li><a href="#_3">光线追踪模型</a><ul>
<li><a href="#_4">生成初始入射光线</a></li>
<li><a href="#_5">物体求交</a><ul>
<li><a href="#_6">球体求交</a></li>
<li><a href="#_7">平面求交</a></li>
<li><a href="#_8">多面体求交</a></li>
</ul>
</li>
<li><a href="#_9">计算漫反射光</a></li>
<li><a href="#_10">计算折射光</a></li>
<li><a href="#_11">计算镜面反射光</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_12">参考文献</a></li>
<li><a href="#_13">未完待续</a></li>
</ul>
</div>
        </nav>
      </div>
      <!-- main outer -->
      <main class="demo-main mdl-layout__content">
      <!-- grid start -->
      <div class="demo-container mdl-grid">
        <!-- placeholder cell -->
        <div class="mdl-cell mdl-cell--2-col mdl-cell--hide-tablet mdl-cell--hide-phone"></div>
        <div class="demo-content mdl-color--white mdl-shadow--4dp content mdl-color-text--grey-800 mdl-cell mdl-cell--8-col">
          <h1> <center>光线追踪</center> </h1>

<!-- 画布popup -->

<style type="text/css">
.box {
  width: 40%;
  margin: 0 auto;
  background: rgba(255,255,255,0.2);
  padding: 35px;
  border: 2px solid #fff;
  border-radius: 20px/50px;
  background-clip: padding-box;
  text-align: center;
}

.button {
  font-size: 1em;
  padding: 10px;
  color: #000;
  border: 2px solid #06D85F;
  border-radius: 20px/50px;
  text-decoration: none;
  cursor: pointer;
  transition: all 0.3s ease-out;
}
.button:hover {
  background: #06D85F;
}

.overlay {
  position: fixed;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  background: rgba(0, 0, 0, 0.7);
  transition: opacity 500ms;
  visibility: hidden;
  opacity: 0;
  z-index: 1000;
}
.overlay:target {
  visibility: visible;
  opacity: 1;
}

.popup {
  margin: 130px auto;
  padding: 20px;
  background: #fff;
  border-radius: 5px;
  width: 80%;
  position: relative;
  transition: all 5s ease-in-out;
}

.popup h2 {
  margin-top: 0;
  color: #333;
  font-family: Tahoma, Arial, sans-serif;
}
.popup .close {
  position: absolute;
  top: 20px;
  right: 30px;
  transition: all 200ms;
  font-size: 30px;
  font-weight: bold;
  text-decoration: none;
  color: #333;
}
.popup .close:hover {
  color: #06D85F;
}
.popup .content {
  max-height: 80%;
  overflow: auto;
}

@media screen and (max-width: 700px){
  .box{
    width: 70%;
  }
  .popup{
    width: 70%;
  }
}
</style>

<div class="box">
    <a class="button" href="#popup1" onclick="resume();">启动光线追踪动画</a>
</div>

<div id="popup1" class="overlay">
    <div class="popup">
        <h2>光线追踪实时渲染</h2>
        <a class="close" href="#" onclick="stop();">&times;</a>
        <div class="content">
            <center>
                <canvas id="paper"  height="200"></canvas>
            </center>
        </div>
    </div>
</div>

<!-- <center>
    <canvas id="paper"  height="200"></canvas>
</center>
 -->

<script type="text/javascript">
var ctx;    // 绘制context
var pixels; // 像素点
var screen_width = 320; // 宽
var screen_height = 200; // 高
var frame = 0;   // 帧
var animate = 0; // 是否动画

// 初始化
function init() {
    ctx = document.getElementById('paper').getContext('2d');
    pixels = ctx.createImageData(screen_width, screen_height);
};
// 绘制
function draw() {
    computeScene(); // 旋转物体后重新计算场景
    ctx.putImageData(pixels, 0, 0);
    // 通过frame更新位置
    frame++;
    if (animate) {
        setTimeout(draw, 1000/25);
    };
};
// 暂停
function stop() {
    animate = 0;
}
// 恢复
function resume() {
    animate = 1;
    setTimeout(draw, 1000);
}

/* 向量类
 * 默认初始化为(0,0,0)
 * 
 */
function Vector(x,y,z) {
    if (arguments.length == 0) {
        x = y = z = 0;
    }
    this.x = x;
    this.y = y;
    this.z = z;
}
Vector.prototype = {
    // 设置x, y, z
    set: function(x,y,z) {
        this.x = x;
        this.y = y;
        this.z = z;
    },
    // 向量长度
    magnitude: function() {
        return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
    },
    // 归一化
    normalize: function() {
        var m = this.magnitude();
        if (m == 0) m = 1;
        this.x /= m;
        this.y /= m;
        this.z /= m;
        return this;
    },
    // 点乘
    dot_product: function(v) {
        return (this.x*v.x + this.y*v.y + this.z*v.z);
    },
    // 减法
    sub: function(v) {
        var r = new Vector(this.x-v.x, this.y-v.y, this.z-v.z);
        return r;
    }
}

/* 光线
 * origin: 源点
 * direction: 方向
 */
function Ray() {
    this.origin = new Vector();
    this.direction = new Vector();
}
/* Sphere
 * center: 中心点，radius: 半径
 */
function Sphere() {
    this.type = "sphere";
    this.center = new Vector();
    this.radius = 1.0;
}
Sphere.prototype = {
    // 球体上一点的法线
    normalToPoint: function(x,y,z) {
        x -= this.center.x;
        y -= this.center.y;
        z -= this.center.z;
        // 归一化 
        x /= this.radius;
        y /= this.radius;
        z /= this.radius;
        return {x: x, y: y, z: z};
    },
    /* 球面求交
     * 输入参数: ray
     * 返回值: type和dist(距离).
     * Type的值:
     * 0: 无交点
     * 1: 相交，视点在球体内部
     * -1: 相交，视点在球体外部
     * 注意，ray的direction需要归一化
     */
    intersect: function(ray) {
        var x, y, z, distance = +Infinity;
        // 光线源点到射线的向量
        x = this.center.x - ray.origin.x;
        y = this.center.y - ray.origin.y;
        z = this.center.z - ray.origin.z;
        // (x,y,z)·(x, y, z)
        var xyz_dot = (x*x)+(y*y)+(z*z);
        var b = (x*ray.direction.x)+(y*ray.direction.y)+(z*ray.direction.z);
        var disc = b*b - xyz_dot + this.radius*this.radius;

        var type = 0;
        if (disc > 0) {
            var d = Math.sqrt(disc);
            var root1 = b-d;
            var root2 = b+d;
            if (root2 > 0) {
                if (root1 < 0) {
                    if (root2 < distance) { distance = root2; type = -1; }
                } else {
                    if (root1 < distance) { distance = root1; type = 1; }
                }
            }
        }
        return {type: type, dist: distance};
    }
}
/* 平面
 * 三个点确定一个平面
 */
function Plane(x1,y1,z1,x2,y2,z2,x3,y3,z3) {
    /* 平面内部表示为:
     * ax + by + cz + d = 0
     * (a, b, c)为平面的法线
     */
    var v1x = x1-x2, v1y = y1-y2, v1z = z1-z2;
    var v2x = x1-x3, v2y = y1-y3, v2z = z1-z3;

    // 法线
    var nx = (v1y*v2z)-(v1z*v2y);
    var ny = (v1z*v2x)-(v1x*v2z);
    var nz = (v1x*v2y)-(v1y*v2x);

    // 代入一点坐标求解d
    this.normal = new Vector(nx,ny,nz);
    this.d = -(nx*x1 + ny*y1 + nz*z1);
}
Plane.prototype = {
    normalToPoint: function(x,y,z) {
        return this.normal;
    },
    intersect: function(ray) {
        var type = 0;
        var distance = +Infinity;
        // 首先检查是否与平面相交
        var ndotrd = (this.normal.x * ray.direction.x) +
                     (this.normal.y * ray.direction.y) +
                     (this.normal.z * ray.direction.z);
        if (ndotrd) {
            // 计算交点距离
            var ndoro = (this.normal.x * ray.origin.x) +
                        (this.normal.y * ray.origin.y) +
                        (this.normal.z * ray.origin.z);
            distance = - (ndoro + this.d)/ndotrd;
            // 只有距离为正值时才会相交
            if (distance > 0) type = 1;
        }
        return {type: type, dist: distance};
    }
}
/* 多面体
 * 通过data构造形状
 * vertices, 顶点坐标;
 * faces, 面的顶点索引数组;(一个面由多个顶点组成) 
 * center, 中心点，作为多面体的内部的一点，用于对物体进行变换
 * transform, 物体的变换，平移旋转等操作
 */
function Geometry(data) {
    this.type = 'Geometry';
    this.center = data['center'];
    this.vertices = data['vertices'];
    this.faces = data['faces'];
    this.faces_plane = [];

    for (var i = 0; i <= data['faces'].length - 1; i++) {
        var f = data['faces'][i];
        var v0 = data['vertices'][ f[0] ];
        var v1 = data['vertices'][ f[1] ];
        var v2 = data['vertices'][ f[2] ];
        this.faces_plane[i] = new Plane(v0[0], v0[1], v0[2],
                                        v1[0], v1[1], v1[2],
                                        v2[0], v2[1], v2[2]);
    };
    // 求解最大的包围半径
    this.radius = -Infinity;
    for (var i = data['vertices'].length - 1; i >= 0; i--) {
        var v = data['vertices'][i];
        var c = data['center'];
        var vc = new Vector(v[0] - c[0], v[1] - c[1], v[2] - v[2]);
        var l = vc.magnitude();
        this.radius = this.radius > l ? this.radius : l;
    };
    this.transform = [
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 1]
    ];
};
function getQuadrant(x, y) {
    if (x >= 0 && y >= 0)
        return 0;
    else if (x < 0 && y >= 1)
        return 1;
    else if (x < 0 && y < 0)
        return 2;
    else
        return 3;
}
var signTable = [
    [ 0,  1,  2, -1],
    [-1,  0,  1,  2],
    [ 2, -1,  0,  1],
    [ 1,  2, -1,  0]
];
function transformMulTransform(t1, t2) {
    var result = [];
    for (var i = 0; i < 3; i++) {
        var t = [];
        t[0] = t1[i][0]*t2[0][0] + t1[i][1]*t2[1][0] + t1[i][2]*t2[2][0];
        t[1] = t1[i][0]*t2[0][1] + t1[i][1]*t2[1][1] + t1[i][2]*t2[2][1];
        t[2] = t1[i][0]*t2[0][2] + t1[i][1]*t2[1][2] + t1[i][2]*t2[2][2];
        result[i] = t;
    };
    return result;
};
function xyzMultTransform(xyz, transform) {
    var result = [];
    result[0] = xyz[0]*transform[0][0] + xyz[1]*transform[1][0] + xyz[2]*transform[2][0];
    result[1] = xyz[0]*transform[0][1] + xyz[1]*transform[1][1] + xyz[2]*transform[2][1];
    result[2] = xyz[0]*transform[0][2] + xyz[1]*transform[1][2] + xyz[2]*transform[2][2];
    return result;
};
Geometry.prototype = {
    makeTransform: function() {
        this.center = xyzMultTransform(this.center, this.transform);
        for (var i = this.vertices.length - 1; i >= 0; i--) {
            this.vertices[i] = xyzMultTransform(this.vertices[i], this.transform);
        };
        this.buildPlanes();
    },
    // 构造面所在的平面，及包围球体
    buildPlanes: function() {
        this.faces_plane = [];
        for (var i = 0; i <= this.faces.length - 1; i++) {
            var f = this.faces[i];
            var v0 = this.vertices[ f[0] ];
            var v1 = this.vertices[ f[1] ];
            var v2 = this.vertices[ f[2] ];
            this.faces_plane[i] = new Plane(v0[0], v0[1], v0[2],
                                            v1[0], v1[1], v1[2],
                                            v2[0], v2[1], v2[2]);
        };
        for (var i = this.vertices.length - 1; i >= 0; i--) {
            var v = this.vertices[i];
            var c = this.center;
            var vc = new Vector(v[0] - c[0], v[1] - c[1], v[2] - v[2]);
            var l = vc.magnitude();
            this.radius = this.radius > l ? this.radius : l;
        };
    },
    // 求解交点法线
    normalToPoint: function(x, y, z) {
        var index = 0;
        var distance = +Infinity;

        for (var i = this.faces_plane.length - 1; i >= 0; i--) {
            var p_n = this.faces_plane[i].normal;
            var p_d = this.faces_plane[i].d;
            // if (Math.abs(x*p_n.x + y*p_n.y + z*p_n.z + p_d) < 1e-16) {
            //     planes.push(this.faces_plane[i]);
            // };
            var p_distance = Math.abs(x*p_n.x + y*p_n.y + z*p_n.z + p_d);
            if (distance > p_distance) {
                distance = p_distance;
                index = i;
            };
        };
        if (distance > 1e-6) {
            console.log(distance);
        };
        return this.faces_plane[index].normal;
    },
    intersect: function(ray) {
        var type = 0;
        var distance = +Infinity;

        // 光线源点到中心的向量
        x = this.center[0] - ray.origin.x;
        y = this.center[1] - ray.origin.y;
        z = this.center[2] - ray.origin.z;
        // (x,y,z)·(x,y,z)
        var xyz_dot = (x*x)+(y*y)+(z*z);
        // (x,y,z)·(rdx,rdy,rdz)
        var b = (x*ray.direction.x)+(y*ray.direction.y)+(z*ray.direction.z);
        // 看是否与外围球体相交
        var disc = b*b - xyz_dot + this.radius*this.radius;
        if (disc > 0) {
            var result = [];
            for (var i = 0; i <= this.faces_plane.length - 1; i++) {
                // 先看是否与每一个平面相交
                var p = this.faces_plane[i];
                result[i] = p.intersect(ray);
                if (result[i].type == 1) {
                    // 检查是否在多边形内部，使用改进的弧长法
                    var f = this.faces[i];
                    distance = result[i].dist;
                    var px = ray.origin.x + ray.direction.x*distance,
                    py = ray.origin.y + ray.direction.y*distance;

                    // 该平面点的分布
                    var coord = [];
                    for (var j = 0; j < f.length; j++) {
                        var v = this.vertices[ f[j] ];
                        var deltax = v[0] - px, deltay = v[1] - py;
                        coord[j] = [deltax, deltay];
                    };
                    coord[f.length] = coord[0]; // coord中存放的是移动坐标系后的顶点的坐标

                    var n = 0;
                    var on_line = false;
                    for (var j = 1; j <= coord.length - 1; j++) {
                        // 获取点所在的象限
                        var g0 = getQuadrant(coord[j-1][0], coord[j-1][1]);
                        var g1 = getQuadrant(coord[j][0], coord[j][1]);
                        // 弧长增量
                        var addition = signTable[g0][g1];
                        if (addition == 2) {
                            var f = coord[j][1] * coord[j-1][0] - coord[j][0]*coord[j-1][1];
                            if (f > 0) {
                                addition = 2;
                            } else if (f == 0) {
                                on_line = true;
                                break;
                            } else {
                                addition = -2;
                            }
                        };
                        n += addition;
                    };
                    if (n == 0 && on_line) {
                        result[i].type = 0;
                    };
                };
            };
            for (var i = result.length - 1; i >= 0; i--) {
                if (result[i].type != 0) {
                    type = result[i].type;
                    // type = -1;
                    distance = (distance > result[i].dist) ? result[i].dist : distance;
                };
            };
            // if (type != 0) {
            //     // 光源在内部还是外部

            // };
        };
        return {type: type, dist: distance};
    }
}
// 灯光
function Light() {
    this.type = "light";
    this.center = new Vector();
}
// 物体
function Solid(name, o) {
    this.name = name;
    this.o = o;
    this.color = {r: 1, g: 1, b: 1};
    this.specularity = 0;
    this.reflection = 0;
}
// 场景
function Scene() {
    this.objects = [];
    this.lights = [];
}
Scene.prototype = {
    addObject: function(o) {
        this.objects.push(o);
        return o;
    },
    addLight: function(o) {
        this.lights.push(o);
        return o;
    },
    traceRay: function (ray, depth) {
        var obj = null;
        var color = {r: 0, g: 0, b: 0};
        var distance = +Infinity;
        for (var j = 0; j < this.objects.length; j++) {
            var test_obj = this.objects[j];
            var res = test_obj.o.intersect(ray);
            if (res.type) {
                if (obj == null || res.dist < distance) {
                    obj = test_obj;
                    distance = res.dist;
                }
            }
        }
        // 如果碰到了物体，求解颜色
        if (obj) {
            // 求解交点
            var x = ray.origin.x + ray.direction.x*distance,
                y = ray.origin.y + ray.direction.y*distance,
                z = ray.origin.z + ray.direction.z*distance;
            // 交点处的法线
            var normal = obj.o.normalToPoint(x,y,z);

            for (var j = 0; j < this.lights.length; j++) {
                var light = this.lights[j];
                // 计算光线到交点的向量
                var lx = light.o.center.x - x;
                var ly = light.o.center.y - y;
                var lz = light.o.center.z - z;
                // 归一化
                var len = Math.sqrt(lx*lx + ly*ly + lz*lz);
                if (len == 0) len = 1;
                lx /= len;
                ly /= len;
                lz /= len;
                // 阴影计算
                var pldistance = Math.sqrt(
                    (x-light.o.center.x)*(x-light.o.center.x)+
                    (y-light.o.center.y)*(y-light.o.center.y)+
                    (z-light.o.center.z)*(z-light.o.center.z));
                var sray = new Ray();

                sray.origin.set(x,y,z);
                // 增加一小点，避免光线与当前点相交
                sray.origin.x += lx/10000;
                sray.origin.y += ly/10000;
                sray.origin.z += lz/10000;
                sray.direction.set(lx, ly, lz);
                var shadow = false;

                for (var i = 0; i < this.objects.length; i++) {
                    var test_obj = this.objects[i];
                    var res = test_obj.o.intersect(sray);
                    if (res.type && res.dist < pldistance) {
                        shadow = true;
                        break;
                    }
                }
                if (shadow) continue; // 如果被遮挡，则计算下一个光线
                // 漫反射 
                var cosine = normal.x*lx+normal.y*ly+normal.z*lz;
                if (cosine < 0) cosine = 0;
                color.r += cosine * obj.color.r * light.color.r;
                color.g += cosine * obj.color.g * light.color.g;
                color.b += cosine * obj.color.b * light.color.b;
                // 折射
                if (obj.specularity > 0) {
                    var vrx = lx - normal.x * cosine * 2,
                        vry = ly - normal.y * cosine * 2,
                        vrz = lz - normal.z * cosine * 2;
                    var cosSigma = (ray.direction.x*vrx)+
                                   (ray.direction.y*vry)+
                                   (ray.direction.z*vrz);
                    if (cosSigma > 0) {
                        var specularity = obj.specularity;
                        color.r += light.color.r * specularity * Math.pow(cosSigma,64);
                        color.g += light.color.g * specularity * Math.pow(cosSigma,64);
                        color.b += light.color.b * specularity * Math.pow(cosSigma,64);
                    }
                }
                // 镜面反射
                if (obj.reflection > 0 && depth < 3) {
                    var rr = new Ray();
                    var dotnr = (ray.direction.x * normal.x) +
                                (ray.direction.y * normal.y) +
                                (ray.direction.z * normal.z);
                    rr.origin.set(x,y,z);
                    rr.direction.set(ray.direction.x - 2 * normal.x * dotnr,
                                     ray.direction.y - 2 * normal.y * dotnr,
                                     ray.direction.z - 2 * normal.z * dotnr);
                    rr.origin.x += rr.direction.x / 10000;
                    rr.origin.y += rr.direction.y / 10000;
                    rr.origin.z += rr.direction.z / 10000;
                    var rcolor = this.traceRay(rr,depth+1);
                    color.r *= 1-obj.reflection;
                    color.g *= 1-obj.reflection;
                    color.b *= 1-obj.reflection;
                    color.r += rcolor.color.r * obj.reflection;
                    color.g += rcolor.color.g * obj.reflection;
                    color.b += rcolor.color.b * obj.reflection;
                }
            }
            if (color.r > 1) color.r = 1;
            if (color.g > 1) color.g = 1;
            if (color.b > 1) color.b = 1;
        }
        return {obj: obj, color: color}
    },
    traceScene: function (camera) {
        var ray = new Ray();
        ray.origin = camera.position;
        for (var x = 0; x < screen_width; x++) {
            for (var y = 0; y < screen_height; y++) {
                // ray.direction.set((x-screen_width/2)/100,
                //                   (y-screen_height/2)/100,
                //                   camera.focus);
                // ray.direction = xyzMultTransform(ray.direction, camera.transform);
                var direction = [(x-screen_width/2)/100,
                                  (y-screen_height/2)/100,
                                  camera.focus];
                direction = xyzMultTransform(direction, camera.transform);
                ray.direction.set(direction[0], direction[1], direction[2]);
                ray.direction.normalize();
                var trace = this.traceRay(ray,0);
                var offset = x*4+y*4*screen_width;
                pixels.data[offset+3] = 255;
                pixels.data[offset+0] = trace.color.r*255;
                pixels.data[offset+1] = trace.color.g*255;
                pixels.data[offset+2] = trace.color.b*255;
            }
        }
    }
}
function Camera() {
    this.position = new Vector();
    this.transform = [[1,0,0,0],
                      [0,1,0,0],
                      [0,0,1,0],
                      [0,0,0,1]];
    this.focus = 4.0;
}

// 场景
var scene = new Scene();
var sphere1 = scene.addObject(new Solid("Sphere 1",new Sphere()));
var sphere2 = scene.addObject(new Solid("Sphere 2",new Sphere()));
var g_data = {
    'center': [0, 1, 0],
    'vertices': [[-1, 0, -1], [1, 0, -1], [1, 0, 1], [0, 0, 1],
                 [-2, 2, -2], [2, 2, -2], [2, 2, 2], [-2, 2, 2]],
    'faces': [[0, 1, 2, 3], [0, 1, 5, 4], [1, 2, 6, 5],
              [4, 5, 6, 7], [0, 3, 7, 4], [2, 3, 7, 6]],
};

var geometry = new Geometry(g_data);
var scale_t = [
    [0.1, 0, 0],
    [0, 0.1, 0],
    [0, 0, 0.1]
];
geometry.transform = transformMulTransform(geometry.transform, scale_t);
geometry.makeTransform();
// var gg = scene.addObject(new Solid("Geometry", geometry));
// gg.color.r = 1;
// gg.color.g = .5;
// gg.color.b = .5;
// gg.specularity = .5;
// gg.reflection = .3;

var plane = scene.addObject(new Solid("Ground",new Plane(0,.5,-2,0,.5,-4,2,.5,-2)));

var light1 = scene.addLight(new Solid("Light 1",new Light()));
var light2 = scene.addLight(new Solid("Light 2",new Light()));
var light3 = scene.addLight(new Solid("Light 3",new Light()));

var camera = new Camera();

sphere1.o.radius = 0.5;

sphere2.o.center.x = 0;
sphere2.o.radius = 0.5;
light1.o.center.set(4,-1,-2);
light2.o.center.set(-1,-1,-2);
light3.o.center.set(1,-6,-2);
light1.color.r = .5;
light1.color.g = .5;
light1.color.b = .5;
light2.color.r = .3;
light2.color.g = .3;
light2.color.b = .3;
light3.color.r = .4;
light3.color.g = .4;
light3.color.b = .4;
sphere1.color.r = 1;
sphere1.color.g = .3;
sphere1.color.b = .3;
sphere1.specularity = .5;
sphere1.reflection = .1;
sphere2.color.r = .3;
sphere2.color.g = 1;
sphere2.color.b = .3;
sphere2.specularity = .5;
sphere2.reflection = .1;
plane.color.r = .3;
plane.color.g = .3;
plane.color.b = .3;

camera.position = new Vector(0, 0, -4);

// 绕X轴旋转矩阵
function makeRotateX(angle) {
    var sin_theta = Math.sin(angle / 180.0 * Math.PI);
    var cos_theta = Math.cos(angle / 180.0 * Math.PI);
    return [[1.0, 0.0, 0.0, 0.0],
            [0.0, cos_theta, -sin_theta, 0.0],
            [0.0, sin_theta, cos_theta, 0.0],
            [0.0, 0.0, 0.0, 1.0]];
}
// 绕Y轴旋转矩阵
function makeRotateY(angle) {
    var sin_theta = Math.sin(angle / 180.0 * Math.PI);
    var cos_theta = Math.cos(angle / 180.0 * Math.PI);
    return [[cos_theta, 0.0, -sin_theta, 0.0],
            [0.0, 1.0, 0.0, 0.0],
            [sin_theta, 0.0, cos_theta, 0.0],
            [0.0, 0.0, 0.0, 1.0]];
}
// 绕Z轴旋转矩阵
function makeRotateZ(angle) {
    var sin_theta = Math.sin(angle / 180.0 * Math.PI);
    var cos_theta = Math.cos(angle / 180.0 * Math.PI);
    return [[cos_theta, -sin_theta, 0.0, 0.0],
            [sin_theta, cos_theta, 0.0, 0.0],
            [0.0, 0.0, 1.0, 0.0],
            [0.0, 0.0, 0.0, 1.0]];
}
// 动画过程
function computeScene() {
    var p = parseInt(frame / 36);
    if ( p == 0 || p == 3) {
        var angle =  5.0 * frame * Math.PI / 180.0;
        sphere1.o.center.x = Math.cos(angle);
        sphere1.o.center.z = Math.sin(angle);
        // 旋转摄像机
        if (frame < 18) {
            var theta = -5 * frame * Math.PI / 180.0;
            camera.position.y = 4.0 * Math.sin(theta);
            camera.position.z = -4.0 * Math.cos(theta);
            camera.transform = makeRotateX( 5 * frame);
        } else if (frame < 36) {
            var theta = -5 * (36 - frame) * Math.PI / 180.0;
            camera.position.y = 4.0 * Math.sin(theta);
            camera.position.z = -4.0 * Math.cos(theta);
            camera.transform = makeRotateX( 5 * (36 - frame));
        };
    } else {
        // var zpos = -4;
        // if (frame >= 72) {
        //     z_pos = (frame - 72) / 9.0 - 8;
        // } else {
        //     z_pos = -4 - (frame - 36) / 9.0;
        // }
        // camera.position.z = z_pos;
        var theta = -10 * (frame - 36) * Math.PI / 180.0;
        camera.position.x = 4.0 * Math.sin(theta);
        camera.position.z = -4.0 * Math.cos(theta);
        camera.transform = makeRotateY(10 * (frame - 36));
    };
    scene.traceScene(camera);
    if (frame >= 143) {
        frame = 0;
    };
}
window.onload = function() {init();};
</script>

<h1 id="_1"><a name="user-content-_1" href="#_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>架构设计</h1>
<p>3D成像模型<br />
<center><img alt="ray trace model" src="http://ijinjay.github.io/images/raytrace_model.PNG" /></center><br />
模型中的基本元素：摄像机、场景物体、光源。呈现给用户的是摄像机拍摄到的场景的一部分。</p>
<p>对成像过程进行建模:用户视图是View类，View类包含Camera和Scene，Scene包含Light和Solid。</p>
<div class="codehilite"><pre><span></span>View -|- Camera
      |- Scene -|- Light
                |- Solid
</pre></div>


<p>下面自顶向下对各个类进行设计。</p>
<h2 id="view"><a name="user-content-view" href="#view" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>View类设计</h2>
<p><code>View</code>类管理<code>Scene</code>和<code>Camera</code>，由<code>View</code>类进行成像。<br />
一个<code>View</code>可以有多个<code>Scene</code>，多个<code>Camera</code>。对简单的应用只考虑一个<code>Scene</code>和一个<code>Camera</code>。<br />
在设定好<code>Scene</code>和<code>Camera</code>后，由<code>View</code>类进行成像过程，故而包含一个<code>draw</code>方法。此外<code>View</code>类应控制显示视图的大小，故而包含<code>width</code>和<code>height</code>属性。</p>
<table>
<thead>
<tr>
<th>View</th>
</tr>
</thead>
<tbody>
<tr>
<td>width <br> height <br> scene <br> camera</td>
</tr>
<tr>
<td>draw( )</td>
</tr>
</tbody>
</table>
<h2 id="camera"><a name="user-content-camera" href="#camera" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Camera设计</h2>
<p>摄像机控制用户观察的位置、角度等。故而<code>Camera</code>类包含位置<code>position</code>，方向<code>direction</code>和焦距<code>focus</code>属性。</p>
<table>
<thead>
<tr>
<th>Camera</th>
</tr>
</thead>
<tbody>
<tr>
<td>position<br> direction<br> focus</td>
</tr>
</tbody>
</table>
<h2 id="scene"><a name="user-content-scene" href="#scene" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Scene设计</h2>
<p>一个<code>Scene</code>包含多个<code>Light</code>和多个<code>Solid</code>。<code>Scene</code>中运行光线追踪算法，故而包含<code>raytrace</code>方法。该方法接收一个视线光线<code>ray</code>作为参数，返回颜色值。</p>
<table>
<thead>
<tr>
<th>Scene</th>
</tr>
</thead>
<tbody>
<tr>
<td>lights[ ]<br>solids[ ]</td>
</tr>
<tr>
<td>raytrace( )</td>
</tr>
</tbody>
</table>
<h2 id="light"><a name="user-content-light" href="#light" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Light设计</h2>
<p>没有光源就不能完成光线追踪过程。在本应用中，仅考虑<code>Light</code>为点光源的情况，包含位置<code>position</code>和颜色<code>color</code>信息。</p>
<table>
<thead>
<tr>
<th>Light</th>
</tr>
</thead>
<tbody>
<tr>
<td>position<br>color</td>
</tr>
</tbody>
</table>
<h2 id="solid"><a name="user-content-solid" href="#solid" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Solid设计</h2>
<p>物体<code>Solid</code>是对真实物体的建模，包含形状、颜色、材质等信息，在光线追踪算法中，使用的材质信息主要有反射系数(reflection)，高光系数(specularity)和透明度(transparency)。故有：</p>
<table>
<thead>
<tr>
<th>Solid</th>
</tr>
</thead>
<tbody>
<tr>
<td>data<br>color<br>specularity<br>reflection<br>transparency</td>
</tr>
</tbody>
</table>
<p><code>注：data包括物体的形状，位置等信息。</code></p>
<h1 id="_2"><a name="user-content-_2" href="#_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>详细设计</h1>
<h2 id="_3"><a name="user-content-_3" href="#_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>光线追踪模型</h2>
<p><img alt="raytrace" src="http://ijinjay.github.io/images/raytrace.PNG" /><br />
投影到视图的光可能存在三种光：漫反射光<code>diffuse</code>，镜面反射光<code>Mirror</code>，折射光<code>Refraction</code>。光线追踪从反方向对光进行追踪，使用Phong光照模型，漫反射光的强度与入射角度有关：</p>
<div class="codehilite"><pre><span></span><span class="nx">matte_color</span> <span class="o">=</span> <span class="nx">solid_color</span> <span class="o">*</span> <span class="nx">light_color</span> <span class="o">*</span> <span class="nx">k</span> <span class="o">*</span> <span class="p">(</span><span class="nx">direction</span> <span class="o">*</span> <span class="nx">nomral</span><span class="p">);</span>
</pre></div>


<p>其中，solid_color为物体颜色，light_color为光的颜色，k为漫反射系数，direction为光线方向单位向量，normal为法线方向单位向量。</p>
<p>当物体有高光效果时，对物体颜色进行高光计算，高光效果与<strong>光线的镜面反射方向和视线方向的夹角</strong>有关，只有在一定夹角范围内才具有高光，高光体现为物体上某些地方比周围具有更高的光强：</p>
<div class="codehilite"><pre><span></span><span class="nx">solid_color</span> <span class="o">+=</span> <span class="nx">light_color</span> <span class="o">*</span> <span class="nx">specularity</span> <span class="o">*</span> <span class="nx">pow</span><span class="p">(</span><span class="nx">cosSigma</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
</pre></div>


<p>其中，cosSigma为光线的镜面反射方向与视线方向的夹角(为正有效)。</p>
<p>当物体可以进行镜面反射时，需要对光线进行镜面反射求解镜面反射光：</p>
<div class="codehilite"><pre><span></span><span class="nx">solid_color</span> <span class="o">=</span> <span class="nx">reflection_color</span> <span class="o">*</span> <span class="nx">reflection</span><span class="p">;</span>
</pre></div>


<p>其中，reflection为反射系数，reflection_color为镜面反射颜色。</p>
<p>当物体具有一定透明效果时，物体表面颜色有折射光和镜面反射光组合而来，且折射光和镜面反射光强度按照Fresnel定律组合，即：</p>
<div class="codehilite"><pre><span></span><span class="nx">color</span> <span class="o">=</span> <span class="p">(</span><span class="nx">fresnel</span> <span class="o">*</span> <span class="nx">reflection</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nx">fresnel</span><span class="p">)</span> <span class="o">*</span> <span class="nx">refraction</span> <span class="o">*</span> <span class="nx">transparency</span><span class="p">)</span> <span class="o">*</span> <span class="nx">solid_color</span><span class="p">;</span>
</pre></div>


<p>其中，fresnel为Fresnel系数，transparency为物体的透明度。</p>
<p>此外，如果物体被遮挡，需要对物体表面的颜色添加阴影。</p>
<p>综上，递归形式的追踪过程代码如下：</p>
<div class="codehilite"><pre><span></span><span class="kd">function</span> <span class="nx">raytrace</span><span class="p">(</span><span class="nx">ray</span><span class="p">,</span> <span class="nx">depth</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">depth</span> <span class="o">&gt;</span> <span class="nx">MAX_DEPTH</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 递归的最大深度</span>
        <span class="k">return</span> <span class="nx">Color</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 到达最大递归深度时返回0值</span>
    <span class="p">}</span>
    <span class="nx">interpoint</span> <span class="o">=</span> <span class="nx">scene</span><span class="p">.</span><span class="nx">solids</span><span class="p">.</span><span class="nx">intersection</span><span class="p">(</span><span class="nx">ray</span><span class="p">);</span> <span class="c1">// 求解光线与场景中物体的最近交点</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">interpoint</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 有交点</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">transparency</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">fresnel</span> <span class="o">=</span> <span class="nx">calculate_fresnel</span><span class="p">(</span><span class="nx">interpoint</span><span class="p">,</span> <span class="nx">ray</span><span class="p">);</span>
            <span class="nx">reflection_ray</span> <span class="o">=</span> <span class="nx">get_reflection_ray</span><span class="p">(</span><span class="nx">interpoint</span><span class="p">,</span> <span class="nx">ray</span><span class="p">);</span> <span class="c1">// 求解交点处的反射光线</span>
            <span class="nx">reflection_color</span> <span class="o">=</span> <span class="nx">raytrace</span><span class="p">(</span><span class="nx">reflection_ray</span><span class="p">,</span> <span class="nx">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 递归</span>
            <span class="nx">refraction_ray</span> <span class="o">=</span> <span class="nx">get_refraction_ray</span><span class="p">(</span><span class="nx">interpoint</span><span class="p">,</span> <span class="nx">ray</span><span class="p">);</span> <span class="c1">// 求解交点处的折射光线</span>
            <span class="nx">refraction_color</span> <span class="o">=</span> <span class="nx">raytrace</span><span class="p">(</span><span class="nx">refraction_ray</span><span class="p">,</span> <span class="nx">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 递归求解折射光颜色</span>
            <span class="k">return</span> <span class="nx">fresnel</span> <span class="o">*</span> <span class="nx">reflection_color</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nx">fresnel</span><span class="p">)</span> <span class="o">*</span> <span class="nx">refraction</span> <span class="o">*</span> <span class="nx">transparency</span><span class="p">;</span> <span class="c1">// 返回颜色值</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">for</span> <span class="nx">light</span> <span class="k">in</span> <span class="nx">Lights</span> <span class="p">{</span>
                <span class="nx">diffuse_color</span> <span class="o">=</span> <span class="nx">calculate_diffuse</span><span class="p">(</span><span class="nx">interpoint</span><span class="p">);</span> <span class="c1">// 求解场景在交点处的漫反射光</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">specularity</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">specular_color</span> <span class="o">=</span> <span class="nx">calculate_specular</span><span class="p">(</span><span class="nx">interpoint</span><span class="p">);</span> <span class="c1">// 求解场景在交点处的高光</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">reflection</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">reflection_ray</span> <span class="o">=</span> <span class="nx">get_reflection_ray</span><span class="p">(</span><span class="nx">interpoint</span><span class="p">,</span> <span class="nx">ray</span><span class="p">);</span> <span class="c1">// 求解交点处的镜面光线</span>
                    <span class="nx">reflection_color</span> <span class="o">=</span> <span class="nx">raytrace</span><span class="p">(</span><span class="nx">reflection_ray</span><span class="p">,</span> <span class="nx">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 递归</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="p">(</span><span class="nx">diffuse_color</span> <span class="o">+</span> <span class="nx">reflection</span> <span class="o">*</span> <span class="nx">reflection_color</span> <span class="o">+</span> <span class="nx">specularity</span> <span class="o">*</span> <span class="nx">specular_color</span><span class="p">);</span> <span class="c1">// 返回颜色值</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">background_color</span><span class="p">;</span> <span class="c1">// 无交点时返回背景颜色</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>分析伪代码，可以发现算法实现中的几个关键点：物体求交，求解折射和反射光线。下面，按照光线追踪的过程进行设计。</p>
<h3 id="_4"><a name="user-content-_4" href="#_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>生成初始入射光线</h3>
<p>初始入射光线由<code>View</code>类进行生成。先引入光线数据结构。</p>
<table>
<thead>
<tr>
<th>Ray</th>
</tr>
</thead>
<tbody>
<tr>
<td>origin: 光线源点<br>direction: 方向</td>
</tr>
</tbody>
</table>
<p>其中,<code>origin</code>坐标等于<code>Camera</code>的position属性。<code>direction</code>由下式生成。</p>
<p>$$<br />
direction = \lgroup \frac{x - \frac{width}{2}}{ratio}, -\frac{y - \frac{height}{2}}{ratio}, focus \rgroup \cdot transform<br />
$$</p>
<p>其中$width, height$分别为<code>View</code>的宽高属性值，$ratio$为三维空间中每单位长度在图像像素平面上占用的像素比率，由<code>View</code>控制。$focus$是摄像机的焦距。$transform$是摄像机为中心的坐标系与三维场景空间的坐标系转换矩阵，可以根据<code>camera</code>的<code>direction</code>属性求解。我们可以通过更改<code>Camera</code>的<code>direction</code>来生成不同摄像机方向上的图像帧，组合这些图像帧可以得到摄像机移动的动画效果。</p>
<h3 id="_5"><a name="user-content-_5" href="#_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>物体求交</h3>
<p>基本流程：对场景中的每一个物体与入射进行求交，如果存在交点就添加到一个临时的交点数组中，接着遍历该数组，得到距离最近的那个交点，及该交点处的相关信息。相关信息包括交点位置，交点处的法线，交点所在的物体颜色信息等等。故而定义求交后的返回信息结构如下：</p>
<div class="codehilite"><pre><span></span><span class="nx">result</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">point</span><span class="o">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="c1">// 交点坐标</span>
    <span class="nx">distance</span><span class="o">:</span> <span class="o">+</span><span class="kc">Infinity</span><span class="p">,</span> <span class="c1">// 交点到光源点的距离</span>
    <span class="nx">normal</span><span class="o">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="c1">// 交点处的法线</span>
    <span class="nx">solid</span><span class="o">:</span> <span class="nx">solid</span><span class="p">,</span> <span class="c1">// 交点所在的物体，用于求解折射光线、获取交点处的颜色</span>
<span class="p">}</span>
</pre></div>


<h4 id="_6"><a name="user-content-_6" href="#_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>球体求交</h4>
<p>球体的信息包含球心坐标center和半径radius。与光线求交：</p>
<p><center><img alt="球面求交" src="http://ijinjay.github.io/images/sphere_inter.PNG" /></center></p>
<h4 id="_7"><a name="user-content-_7" href="#_7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>平面求交</h4>
<p>三点确定一个平面，平面数据结构包含三个不在同一条直线上的点的坐标$P_1(x_1, y_1, z_1), P_2(x_2, y_2, z_2), P_3(x_3, y_3, z_3)$。平面内部表示为</p>
<p>$$ax+by+cz+d=0$$</p>
<p>(a,b,c)为平面的法线方向。通过三点坐标求解(a,b,c,d):</p>
<p>$$<br />
\vec n = (a, b, c) \\<br />
\vec {P_1P_2}\vec {P_1P_3}\vec n = 0 \\<br />
\vec n \cdot P_1 + d = 0<br />
$$</p>
<p>与光线求交：<br />
1. 先检查是否与平面平行，判断$\vec n \cdot \vec d = 0$，其中$\vec d$为光线方向。<br />
2. 不平行的情况下，计算交点距离。</p>
<p><center><img alt="平面求交" src="http://ijinjay.github.io/images/plane_inter.png" /></center></p>
<h4 id="_8"><a name="user-content-_8" href="#_8" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>多面体求交</h4>
<p>多面体有多个顶点和多个面，故而包含一个vertices和faces数组，为了方便操作，添加一个center中心点坐标，便于计算交点法线的方向。完整的多面体数据结构如下:</p>
<table>
<thead>
<tr>
<th>数据</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>类型，默认为&rdquo;Geometry&rdquo;</td>
</tr>
<tr>
<td>center</td>
<td>多面体中心坐标</td>
</tr>
<tr>
<td>vertices</td>
<td>顶点坐标数组</td>
</tr>
<tr>
<td>faces</td>
<td>面的顶点索引数组，一个面有多个顶点组成，使用顶点索引表示顶点</td>
</tr>
<tr>
<td>faces_plane</td>
<td>通过faces构建的面平面，用于求交过程</td>
</tr>
<tr>
<td>transform</td>
<td>多面体当前位置的变换，用于更改多面体的位置，大小</td>
</tr>
</tbody>
</table>
<ol>
<li>与光线求交时，依次对每个面进行求交，与各个面距离最近的那个即为所求。</li>
<li>与面求交时直接采用与平面求交的方法，求得交点后，判断交点是否在顶点围成的多边形内部。</li>
</ol>
<p>采用弧长法判断交点是否在多边形内部：</p>
<ol>
<li>降维，交点所在的法线为$\vec n$，去掉$\vec n$中数值最大的分量坐标组合成新的坐标$(x\prime ,y\prime )$，并应用到所有该面的顶点坐标及交点坐标;</li>
<li>将坐标原点移到交点P处，各个象限点的符号分别为(+, +),(-,+),(-,-),(+,-)。若某个坐标为0，则符号为+。符号对变换与弧长变化的关系：<div class="codehilite"><pre><span></span>[0, 1, 2, -1], // 第一象限到一，二，三，四象限
[-1, 0, 1, 2], // 第二象限到一，二，三，四象限
[2, -1, 0, 1], // 第三象限到一，二，三，四象限
[1, 2, -1, 0], // 第四象限到一，二，三，四象限
</pre></div>


</li>
</ol>
<p>其中1表示$\pi / 2$; -1表示$\pi/2$; 2表示$\pm \pi$, 此时，设$(x_i, y_i)$和$(x_{i+1}, y_{i+1})$为边的起点和终点坐标，计算$$f = y_{i+1}x_i - x_{i+1}y_i $$若$f=0$，则边穿过坐标原点。若$f&gt;0$，则弧长加$\pi$；若$f&lt;0$，则弧长减少$\pi$。</p>
<p>最后，代数和为0，点在多边形外部；代数和为$2\pi$，点在多边形内部；代数和为0，点在多边形边上。</p>
<h3 id="_9"><a name="user-content-_9" href="#_9" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>计算漫反射光</h3>
<p>基本流程：对场景中的每一个光源，计算是否可以直接到达交点(交点与光源的连线不与任何物体相交)。如果可以到达，返回该光源作用于该点的漫反射光颜色；如果不能到达，则该光源在该点的漫反射光作用为0。</p>
<p>计算漫反射的公式如下：</p>
<p>$$diffuse\_color = solid.color \times \sum^{Lights}_{light}(light.color \cdot distance \cdot \cos\theta)$$</p>
<p>其中，$solid.color$为物体表面的颜色，$light.color$为光源颜色，$distance$为交点与光源的距离，$\theta$为交点与光源连线与该点处法线的夹角。</p>
<h3 id="_10"><a name="user-content-_10" href="#_10" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>计算折射光</h3>
<p><img alt="折射" src="http://ijinjay.github.io/images/refraction.PNG" /><br />
折射光计算需要了解折射面上下的折射率。折射过程满足$\sin\theta_1\cdot N_1 = \sin\theta_2\cdot N_2$。三维情况下如何求解折射方向？</p>
<p>记单位长度的入射光线方向为$\vec a = (x_a, y_a, z_a)$,单位长度的法线方向为$\vec n = (x_n, y_n, z_n)$,单位长度的折射方向为$\vec b = (x_b, y_b, z_b)$，三个向量在同一个平面内，则有三向量的混合积为0(或者有$\vec B$可以由$\vec A$和$\vec N$表示)有</p>
<p>$$<br />
\begin{cases}<br />
\vec b = \vec a + k \cdot \vec n  \\ <br />
N_1^2 \cdot (1 - (\vec a \cdot \vec n)^2) &amp; = N_2^2 \cdot(1-(\vec b \cdot \vec n)^2) <br />
\end{cases}<br />
$$</p>
<p>化解上式我们可以得到关于$k$的二次方程：</p>
<p>$$k^2 + 2(\vec a\cdot \vec n)k + (1-(\frac{N_2}{N_1})^2) = 0$$</p>
<p>求解二次方程可能会得到两个k值，根据折射定理，使得$\vec a\cdot \vec b$值更大的k值为所求的折射光线的系数，进而得到折射光线方向：</p>
<div class="codehilite"><pre><span></span><span class="nx">refraction_ray</span> <span class="o">=</span> <span class="nx">uniform_light</span> <span class="o">+</span> <span class="nx">k</span> <span class="o">*</span> <span class="nx">uniform_normal</span>
</pre></div>


<h3 id="_11"><a name="user-content-_11" href="#_11" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>计算镜面反射光</h3>
<p><img alt="镜面反射" src="http://ijinjay.github.io/images/mirror.png" /></p>
<p>镜面反射光线计算可用向量计算简洁的得出，如上图中的入射光线A，反射光线B可以按如下计算：</p>
<p>$\vec B = \vec A + 2(\vec N - \vec A) = 2 \vec N - \vec A$</p>
<p>实际计算时，对于单位长度的入射光线$\vec a$和单位长度的折射光线$\vec n$，有</p>
<p>$\vec b = \vec a - 2(\vec a\cdot \vec n)\vec n$</p>
<h1 id="_12"><a name="user-content-_12" href="#_12" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>参考文献</h1>
<p><a href="http://antirez.com/misc/rt.html">jsrt</a><br />
<a href="http://www.cosinekitty.com/raytrace/contents.html">Fundamentals of Ray Tracing</a></p>
<h1 id="_13"><a name="user-content-_13" href="#_13" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>未完待续</h1>
  <p style="text-align: right; color: gray;"><br>2018-08-16 16:15:50</p>
        </div>
      </div>
      <footer>
        <p>
          JinJay's blog<a href="https://github.com/ijinjay" target="_blank">@JinJay</a>.
        </p>
        <script src="http://s4.cnzz.com/z_stat.php?id=1253269299&amp;web_id=1253269299" language="JavaScript"></script>
      </footer>
      </main>
    </div>
  </body>
</html>

