<!doctype html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="date" content="2016-12">
<meta name="keywords" content="Ceres,Ceres Solver,Ceres Bundle Adjustment">
<meta name="author" content="Jin Jay">
<meta name="description" content="Google非线性优化Ceres库的使用。"><style>
</style><style>.codehilite pre .hll { background-color: #ffffcc }
.codehilite pre  { background: #f0f3f3; }
.codehilite pre .c { color: #0099FF; font-style: italic } /* Comment */
.codehilite pre .err { color: #AA0000; background-color: #FFAAAA } /* Error */
.codehilite pre .k { color: #006699; font-weight: bold } /* Keyword */
.codehilite pre .o { color: #555555 } /* Operator */
.codehilite pre .ch { color: #0099FF; font-style: italic } /* Comment.Hashbang */
.codehilite pre .cm { color: #0099FF; font-style: italic } /* Comment.Multiline */
.codehilite pre .cp { color: #009999 } /* Comment.Preproc */
.codehilite pre .cpf { color: #0099FF; font-style: italic } /* Comment.PreprocFile */
.codehilite pre .c1 { color: #0099FF; font-style: italic } /* Comment.Single */
.codehilite pre .cs { color: #0099FF; font-weight: bold; font-style: italic } /* Comment.Special */
.codehilite pre .gd { background-color: #FFCCCC; border: 1px solid #CC0000 } /* Generic.Deleted */
.codehilite pre .ge { font-style: italic } /* Generic.Emph */
.codehilite pre .gr { color: #FF0000 } /* Generic.Error */
.codehilite pre .gh { color: #003300; font-weight: bold } /* Generic.Heading */
.codehilite pre .gi { background-color: #CCFFCC; border: 1px solid #00CC00 } /* Generic.Inserted */
.codehilite pre .go { color: #AAAAAA } /* Generic.Output */
.codehilite pre .gp { color: #000099; font-weight: bold } /* Generic.Prompt */
.codehilite pre .gs { font-weight: bold } /* Generic.Strong */
.codehilite pre .gu { color: #003300; font-weight: bold } /* Generic.Subheading */
.codehilite pre .gt { color: #99CC66 } /* Generic.Traceback */
.codehilite pre .kc { color: #006699; font-weight: bold } /* Keyword.Constant */
.codehilite pre .kd { color: #006699; font-weight: bold } /* Keyword.Declaration */
.codehilite pre .kn { color: #006699; font-weight: bold } /* Keyword.Namespace */
.codehilite pre .kp { color: #006699 } /* Keyword.Pseudo */
.codehilite pre .kr { color: #006699; font-weight: bold } /* Keyword.Reserved */
.codehilite pre .kt { color: #007788; font-weight: bold } /* Keyword.Type */
.codehilite pre .m { color: #FF6600 } /* Literal.Number */
.codehilite pre .s { color: #CC3300 } /* Literal.String */
.codehilite pre .na { color: #330099 } /* Name.Attribute */
.codehilite pre .nb { color: #336666 } /* Name.Builtin */
.codehilite pre .nc { color: #00AA88; font-weight: bold } /* Name.Class */
.codehilite pre .no { color: #336600 } /* Name.Constant */
.codehilite pre .nd { color: #9999FF } /* Name.Decorator */
.codehilite pre .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite pre .ne { color: #CC0000; font-weight: bold } /* Name.Exception */
.codehilite pre .nf { color: #CC00FF } /* Name.Function */
.codehilite pre .nl { color: #9999FF } /* Name.Label */
.codehilite pre .nn { color: #00CCFF; font-weight: bold } /* Name.Namespace */
.codehilite pre .nt { color: #330099; font-weight: bold } /* Name.Tag */
.codehilite pre .nv { color: #003333 } /* Name.Variable */
.codehilite pre .ow { color: #000000; font-weight: bold } /* Operator.Word */
.codehilite pre .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite pre .mb { color: #FF6600 } /* Literal.Number.Bin */
.codehilite pre .mf { color: #FF6600 } /* Literal.Number.Float */
.codehilite pre .mh { color: #FF6600 } /* Literal.Number.Hex */
.codehilite pre .mi { color: #FF6600 } /* Literal.Number.Integer */
.codehilite pre .mo { color: #FF6600 } /* Literal.Number.Oct */
.codehilite pre .sa { color: #CC3300 } /* Literal.String.Affix */
.codehilite pre .sb { color: #CC3300 } /* Literal.String.Backtick */
.codehilite pre .sc { color: #CC3300 } /* Literal.String.Char */
.codehilite pre .dl { color: #CC3300 } /* Literal.String.Delimiter */
.codehilite pre .sd { color: #CC3300; font-style: italic } /* Literal.String.Doc */
.codehilite pre .s2 { color: #CC3300 } /* Literal.String.Double */
.codehilite pre .se { color: #CC3300; font-weight: bold } /* Literal.String.Escape */
.codehilite pre .sh { color: #CC3300 } /* Literal.String.Heredoc */
.codehilite pre .si { color: #AA0000 } /* Literal.String.Interpol */
.codehilite pre .sx { color: #CC3300 } /* Literal.String.Other */
.codehilite pre .sr { color: #33AAAA } /* Literal.String.Regex */
.codehilite pre .s1 { color: #CC3300 } /* Literal.String.Single */
.codehilite pre .ss { color: #FFCC33 } /* Literal.String.Symbol */
.codehilite pre .bp { color: #336666 } /* Name.Builtin.Pseudo */
.codehilite pre .fm { color: #CC00FF } /* Name.Function.Magic */
.codehilite pre .vc { color: #003333 } /* Name.Variable.Class */
.codehilite pre .vg { color: #003333 } /* Name.Variable.Global */
.codehilite pre .vi { color: #003333 } /* Name.Variable.Instance */
.codehilite pre .vm { color: #003333 } /* Name.Variable.Magic */
.codehilite pre .il { color: #FF6600 } /* Literal.Number.Integer.Long */</style><script type="text/javascript" src="http://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
MathJax.Hub.Config({
  config: ["MMLorHTML.js"],
  extensions: ["tex2jax.js"],
  jax: ["input/TeX"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    processEscapes: false
  },
  TeX: {
    extensions: ["AMSmath.js", "AMSsymbols.js"],
    TagSide: "right",
    TagIndent: ".8em",
    MultLineWidth: "85%",
    equationNumbers: {
      autoNumber: "AMS",
    },
    unicode: {
      fonts: "STIXGeneral,'Arial Unicode MS'"
    }
  },
  showProcessingMessages: false
});
</script>
<title>Ceres使用</title>
    <meta name="robots" content="all" />
    <!-- TODO: 移动设备配置 -->
    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="icon" sizes="192x192" href="../../images/snow.jpg">
    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="JinJay">
    <link rel="apple-touch-icon-precomposed" href="../../images/snow.jpg">
    <!-- Tile icon for Win8 (144x144 + tile color) -->
    <meta name="msapplication-TileImage" content="../../images/snow.jpg">
    <meta name="msapplication-TileColor" content="#3372DF">
    <!-- save to local storage -->
    <link href="../../mdl/icon.css" rel="stylesheet">
    <link href="http://cdn.bootcss.com/material-design-icons/3.0.1/iconfont/material-icons.min.css" rel="stylesheet">
    <!-- random generate color -->
    <link rel="stylesheet" href="../../mdl/material.purple-green.min.css" />
    <!-- template.css -->
    <link rel="stylesheet" type="text/css" href="../../stylesheets/t.css">
    <script src="../../mdl/material.min.js"></script>
  </head>
  <body>
    <!-- Uses a header that contracts as the page scrolls down. -->
    <style>
    .waterfall-demo-header-nav .mdl-navigation__link:last-of-type {
    padding-right: 0;
    }
    }
    </style>
    <div class="mdl-layout mdl-layout--fixed-header mdl-js-layout mdl-layout--overlay-drawer-button">
      <header class="mdl-layout__header mdl-layout__header--waterfall">
        <!-- Top row, always visible -->
        <div class="mdl-layout__header-row">
          <!-- TOC -->
          <span class="mdl-layout-title">目录</span>
          <div class="mdl-layout-spacer"></div>
          <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable
            mdl-textfield--floating-label mdl-textfield--align-right">
            <label class="mdl-button mdl-js-button mdl-button--icon" for="waterfall-exp">
              <i class="material-icons">search</i>
            </label>
            <div class="mdl-textfield__expandable-holder">
              <input class="mdl-textfield__input" type="text" name="sample" id="waterfall-exp" placeholder="暂不可用" />
            </div>
          </div>
        </div>
        <!-- Bottom row, not visible on scroll -->
        <div class="mdl-layout__header-row">
          <span class="mdl-layout-tile mdl-layout--large-screen-only">朝着梦想，一步一步！</span>
          <div class="mdl-layout-spacer"></div>
          <!-- Navigation -->
          <nav class="waterfall-demo-header-nav mdl-navigation">
            <a class="mdl-navigation__link" href="http://ijinjay.github.io">主页</a>
            <a class="mdl-navigation__link" href="http://ijinjay.github.io/blog/">博客</a>
            <a class="mdl-navigation__link" href="http://ijinjay.github.io/about.html">关于我</a>
          </nav>
        </div>
      </header>
      <div class="mdl-layout__drawer">
        <span class="mdl-layout-title">目录</span>
        <nav class="mdl-navigation">
          <div class="toc">
<ul>
<li><a href="#ceres-solver">Ceres Solver使用</a><ul>
<li><a href="#_1">非线性最小二乘</a><ul>
<li><a href="#hello-world">hello world 最简单的例子</a></li>
<li><a href="#_2">微分</a><ul>
<li><a href="#_3">数值微分</a></li>
<li><a href="#_4">分析微分</a></li>
<li><a href="#_5">其他</a></li>
</ul>
</li>
<li><a href="#powell">Powell函数</a></li>
<li><a href="#_6">曲线拟合</a></li>
<li><a href="#_7">鲁棒曲线拟合</a></li>
<li><a href="#bundle-adjustment">Bundle Adjustment 集束调整</a></li>
</ul>
</li>
<li><a href="#_8">通用无约束优化</a><ul>
<li><a href="#rosenbrock">Rosenbrock函数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
        </nav>
      </div>
      <!-- main outer -->
      <main class="demo-main mdl-layout__content">
      <!-- grid start -->
      <div class="demo-container mdl-grid">
        <!-- placeholder cell -->
        <div class="mdl-cell mdl-cell--2-col mdl-cell--hide-tablet mdl-cell--hide-phone"></div>
        <div class="demo-content mdl-color--white mdl-shadow--4dp content mdl-color-text--grey-800 mdl-cell mdl-cell--8-col">
          <h1 id="ceres-solver"><a name="user-content-ceres-solver" href="#ceres-solver" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Ceres Solver使用</h1>
<h2 id="_1"><a name="user-content-_1" href="#_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>非线性最小二乘</h2>
<p>Ceres可以求解以下形式的有界约束非线性最小二乘问题：</p>
<p>$$\min_x \frac12\sum_i\rho_i\left(\left\| f_i(x_{i1},\cdots,x_{ik})\right\|^2 \right) \\ s.t.\quad l_j\le x_j \le u_j $$</p>
<p>这种形式的问题来源于科学工程的多个领域，从统计学的曲线拟合到计算机视觉中从图像中构建三维模型。</p>
<p>表示式中$\rho_i\left(\left\| f_i(x_{i1},\cdots,x_{ik})\right\|^2 \right)$被称为残差块<code>ResidualBlock</code>，其中$f(\cdot)$是依赖于参数块$[x_{i1},\cdots,x_{ik}]$的一个代价函数。$l_j$和$u_j$式参数$x_j$的边界。$\rho(\cdot)$式损耗函数，用于减少离群值outliers对解的影响。作为一个特例，$\rho(x)=x, l_j=-\infty, u_j=+\infty$，有：</p>
<p>$$\frac12\sum_i\left\| f_i(x_{i1},\cdots,x_{ik}) \right\|^2 $$</p>
<h3 id="hello-world"><a name="user-content-hello-world" href="#hello-world" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>hello world 最简单的例子</h3>
<p>我们求解下面方程的最小解<br />
$\frac12(10-x)^2$</p>
<p>第一步，写出代价函数$f(x) = 10 -x$:</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">CostFunctor</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span> <span class="n">x</span><span class="p">),</span> <span class="n">T</span><span class="o">*</span> <span class="n">residual</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">residual</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>需要注意的是，<code>operator()</code>是一个模板方法，假定它的输入和输出都是类型<code>T</code>。这里用模板可以使Ceres使用<code>T=double</code>来调用<code>CostFunctor::operator&lt;T&gt;()</code>来只获得残差的值，或者使用<code>T=Jet</code>来获得雅克比矩阵。后面会介绍更多的细节。</p>
<p>现在使用这个函数来构造非线性优化最小二乘问题并使用Ceres求解。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;ceres/ceres.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;glog/logging.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="n">ceres</span><span class="o">::</span><span class="n">AutoDiffCostFunction</span><span class="p">;</span>
<span class="k">using</span> <span class="n">ceres</span><span class="o">::</span><span class="n">CostFunction</span><span class="p">;</span>
<span class="k">using</span> <span class="n">ceres</span><span class="o">::</span><span class="n">Problem</span><span class="p">;</span>
<span class="k">using</span> <span class="n">ceres</span><span class="o">::</span><span class="n">Solver</span><span class="p">;</span>
<span class="k">using</span> <span class="n">ceres</span><span class="o">::</span><span class="n">Solve</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">CostFunctor</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span> <span class="n">x</span><span class="p">),</span> <span class="n">T</span><span class="o">*</span> <span class="n">residual</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">residual</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">google</span><span class="o">::</span><span class="n">InitGoogleLogging</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="c1">// 变量及其初始值</span>
  <span class="kt">double</span> <span class="n">initial_x</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">initial_x</span><span class="p">;</span>

  <span class="c1">// 创建问题</span>
  <span class="n">Problem</span> <span class="n">problem</span><span class="p">;</span>

  <span class="c1">// 设置问题的代价函数，使用自动微分来获得倒数(jacobian雅可比矩阵)。</span>
  <span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span> <span class="o">=</span>
      <span class="k">new</span> <span class="n">AutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">CostFunctor</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">CostFunctor</span><span class="p">);</span>
  <span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="n">cost_function</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

  <span class="c1">// 运行求解器</span>
  <span class="n">Solver</span><span class="o">::</span><span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
  <span class="n">options</span><span class="p">.</span><span class="n">linear_solver_type</span> <span class="o">=</span> <span class="n">ceres</span><span class="o">::</span><span class="n">DENSE_QR</span><span class="p">;</span>
  <span class="n">options</span><span class="p">.</span><span class="n">minimizer_progress_to_stdout</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">Solver</span><span class="o">::</span><span class="n">Summary</span> <span class="n">summary</span><span class="p">;</span>
  <span class="n">Solve</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">problem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">summary</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">summary</span><span class="p">.</span><span class="n">BriefReport</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;x : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">initial_x</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; -&gt; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>编写对应的<code>CMakeList.txt</code>:</p>
<div class="codehilite"><pre><span></span><span class="nb">CMAKE_MINIMUM_REQUIRED</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.7</span><span class="p">)</span>
<span class="c"># 项目名</span>
<span class="nb">PROJECT</span><span class="p">(</span><span class="s">HelloWorld</span><span class="p">)</span>
<span class="c"># 指定ceres</span>
<span class="nb">FIND_PACKAGE</span><span class="p">(</span><span class="s">ceres</span> <span class="s">REQUIRED</span><span class="p">)</span>
<span class="c"># 需要eigen库</span>
<span class="nb">INCLUDE_DIRECTORIES</span><span class="p">(</span><span class="o">${</span><span class="nv">EIGEN_INCLUDE_DIR</span><span class="o">}</span><span class="p">)</span>
<span class="c"># 目标文件</span>
<span class="nb">ADD_EXECUTABLE</span><span class="p">(</span>
  <span class="s">helloword</span>
  <span class="s">helloword.cc</span>
<span class="p">)</span>
<span class="c"># 链接ceres</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>
  <span class="s">helloworld</span>
  <span class="s">ceres</span>
<span class="p">)</span>
</pre></div>


<p>编译运行</p>
<div class="codehilite"><pre><span></span>mkdir build
<span class="nb">cd</span> build
cmake ..
make
./helloworld
</pre></div>


<h3 id="_2"><a name="user-content-_2" href="#_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>微分</h3>
<p>Ceres与大多数优化库一样，依赖于计算目标函数在任意参数值处的值及对应的微分。Ceres提供了多种方式来计算为微分。在上面的例子中使用了自动微分，下面来看看分析和数值微分。</p>
<h4 id="_3"><a name="user-content-_3" href="#_3" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>数值微分</h4>
<p>在一些情况下，定义一个模板代价函数不太可能，比如函数中包含一个不可控的库函数，这时可以使用数值微分，构造一个<code>NumbericDiffCostFunction</code>：</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">NumericDiffCostFunctor</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="k">const</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">residual</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">residual</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>对应的<code>Problem</code>为:</p>
<div class="codehilite"><pre><span></span><span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span> <span class="o">=</span>
  <span class="k">new</span> <span class="n">NumericDiffCostFunction</span><span class="o">&lt;</span><span class="n">NumericDiffCostFunctor</span><span class="p">,</span> <span class="n">ceres</span><span class="o">::</span><span class="n">CENTRAL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span>
      <span class="k">new</span> <span class="n">NumericDiffCostFunctor</span><span class="p">)</span>
<span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="n">cost_function</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
</pre></div>


<p>一般来讲，建议使用自动微分而不是数值微分，使用C++模板使得自动微分更高效，收敛也更快。</p>
<h4 id="_4"><a name="user-content-_4" href="#_4" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>分析微分</h4>
<p>有时自动微分不可实现，这时可以提供自定义的残差和jacobian计算的代码。先定义一个<code>CostFunction</code>或<code>SizedCostFunction</code>的子类。下面是一个简单的实现示例：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">QuadraticCostFunction</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ceres</span><span class="o">::</span><span class="n">SizedCostFunction</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">QuadraticCostFunction</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Evaluate</span><span class="p">(</span><span class="kt">double</span> <span class="k">const</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">*</span> <span class="n">residuals</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">**</span> <span class="n">jacobians</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">residuals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">-</span> <span class="n">x</span><span class="p">;</span>

    <span class="c1">// 计算Jacobian</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">jacobians</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">jacobians</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">jacobians</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p><code>QuadraticCostFunction::Evaluate</code>提供了一个输入数组<code>parameters</code>，一个残差的输出数组<code>residuals</code>和一个Jacobian矩阵的输出数组<code>jacobians</code>。<code>jacobians</code>是可选的，<code>Evaluate</code>会检查它是否为空，在这个例子中，残差函数是线性的，故而Jacobian是常量。</p>
<blockquote>
<p>除非有一个很好的管理Jacobian的理由，否则建议使用<code>AutoDiffCostFunction</code>或<code>NumericDiffCostFunction</code>。</p>
</blockquote>
<h4 id="_5"><a name="user-content-_5" href="#_5" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>其他</h4>
<p>熟悉了<code>NumericDiffCostFunction</code>和<code>AutoDiffCostFunction</code>后，建议查看<code>DynamicAutoDiffCostFunction</code>, <code>CostFunctionToFunctor</code>, <code>NumericDiffFunctor</code>和<code>ConditionedCostFunction</code>来使用更高级的功能。</p>
<h3 id="powell"><a name="user-content-powell" href="#powell" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Powell函数</h3>
<p>考虑一个复杂的例子，最小化Powell函数，令$x=[x_1,x_2,x_3,x_4]$且</p>
<p>$$<br />
\begin{align*}<br />
f_1(x)&amp;=x_1+10x_2\\<br />
f_2(x)&amp;=\sqrt{5}(x_3-x_4) \\<br />
f_3(x)&amp;=(x_2-2x_3)^2 \\<br />
f_4(x)&amp;=\sqrt{10}(x_1-x_4)^2 \\<br />
F(x)&amp;=[f_1(x), f_2(x), f_3(x), f_4(x)]<br />
\end{align*}<br />
$$</p>
<p>$F(x)$是四个参数的函数，有四个残差，我们希望找到$x$使得$\frac12\left\| F(x)\right\|^2$最小。</p>
<p>首先，第一步是定义目标函数，下面的是$f_4(x_1,x_4)$：</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">F4</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span> <span class="n">x1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span> <span class="n">x4</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">residual</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">residual</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">10.0</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x4</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x4</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>类似的，可以定义函数$F1,F2,F3$，接着构造问题：</p>
<div class="codehilite"><pre><span></span><span class="kt">double</span> <span class="n">x1</span> <span class="o">=</span>  <span class="mf">3.0</span><span class="p">;</span> <span class="kt">double</span> <span class="n">x2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span> <span class="kt">double</span> <span class="n">x3</span> <span class="o">=</span>  <span class="mf">0.0</span><span class="p">;</span> <span class="kt">double</span> <span class="n">x4</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

<span class="n">Problem</span> <span class="n">problem</span><span class="p">;</span>

<span class="c1">// 添加残差项到问题中并使用自动微分</span>
<span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span>
  <span class="k">new</span> <span class="n">AutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">F1</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x2</span><span class="p">);</span>
<span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span>
  <span class="k">new</span> <span class="n">AutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">F2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">F2</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x4</span><span class="p">);</span>
<span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span>
  <span class="k">new</span> <span class="n">AutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">F3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">F3</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x3</span><span class="p">)</span>
<span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span>
  <span class="k">new</span> <span class="n">AutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">F4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">F4</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x4</span><span class="p">);</span>
</pre></div>


<h3 id="_6"><a name="user-content-_6" href="#_6" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>曲线拟合</h3>
<p>上面的例子都是没有数据的简单的优化问题，现在考虑复杂点的问题。问题数据来自采样$y=e^{0.3x+0.1}$，并添加了高斯噪声（标准差为$\delta=0.2$），我们拟合曲线<br />
$$y=e^{mx+c}$$</p>
<p>首先定义一个模板对象来计算残差：</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ExponentialResidual</span> <span class="p">{</span>
  <span class="n">ExponentialResidual</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">x_</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y_</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span> <span class="n">c</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">residual</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">residual</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="n">y_</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">T</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="c1">// Observations for a sample.</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">x_</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">y_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>假定观察值为$2n$大小的数组<code>data</code>，则可以对每一个观测值创建一个<code>CostFunction</code>来构建问题：</p>
<div class="codehilite"><pre><span></span><span class="kt">double</span> <span class="n">m</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

<span class="n">Problem</span> <span class="n">problem</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kNumObservations</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span> <span class="o">=</span>
       <span class="k">new</span> <span class="n">AutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">ExponentialResidual</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span>
           <span class="k">new</span> <span class="n">ExponentialResidual</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]));</span>
  <span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="n">cost_function</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>这个拟合效果不是很好，下面看一种鲁棒的拟合方法。</p>
<h3 id="_7"><a name="user-content-_7" href="#_7" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>鲁棒曲线拟合</h3>
<p>假定数据中有一些outliers，离群值，也即一些数据并不遵循噪声模型。为了处理离群值，一个标准的技术是使用一个<code>LossFunction</code>损耗函数。损耗函数降低了离群值的影响，为了将损耗函数与一个残差块联合，我们修改问题为</p>
<div class="codehilite"><pre><span></span><span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="n">cost_function</span><span class="p">,</span> <span class="k">new</span> <span class="n">CauchyLoss</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
</pre></div>


<p><code>CauchyLoss</code>是Ceres自带的一个损耗函数，参数0.5制定了损耗函数的规模。</p>
<h3 id="bundle-adjustment"><a name="user-content-bundle-adjustment" href="#bundle-adjustment" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Bundle Adjustment 集束调整</h3>
<p>Ceres的主要用处便是用于解决大规模的BA问题。给定一系列图像特征值位置和相关联系，BA的目标是找出3D点的位置和相机参数来最小化重投影误差。这个优化问题通常是非线性最小二乘问题，误差是平方$L_2$范数。下面求解BA问题使用<a href="http://grail.cs.washington.edu/projects/bal/">BAL</a>数据集。</p>
<p>通常第一步是定义一个模板函数来计算重投影误差/残差。这个函数的结构与<code>ExponentialResidual</code>类似。在BAL问题中，每一个残差项依赖于一个三维点和九参数的相机模型。相机模型的九个参数分别为：三个旋转分量，三个平移分量，一个焦距和两个径向畸变。</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">SnavelyReprojectionError</span> <span class="p">{</span>
  <span class="n">SnavelyReprojectionError</span><span class="p">(</span><span class="kt">double</span> <span class="n">observed_x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">observed_y</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">observed_x</span><span class="p">(</span><span class="n">observed_x</span><span class="p">),</span> <span class="n">observed_y</span><span class="p">(</span><span class="n">observed_y</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span> <span class="n">camera</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="k">const</span> <span class="n">point</span><span class="p">,</span>
                  <span class="n">T</span><span class="o">*</span> <span class="n">residuals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
                    <span class="c1">// camera[0,1,2]是旋转分量</span>
    <span class="n">T</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">ceres</span><span class="o">::</span><span class="n">AngleAxisRotatePoint</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="c1">// camera[3,4,5] 平移分量</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">camera</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">camera</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">camera</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

    <span class="c1">// 计算畸变的中心，符号依赖于Noah Snavely的假设</span>
    <span class="c1">// 相机有一个负的z轴</span>
    <span class="n">T</span> <span class="n">xp</span> <span class="o">=</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">T</span> <span class="n">yp</span> <span class="o">=</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

    <span class="c1">// 应用二阶和四阶径向畸变</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">camera</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">camera</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="n">T</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">xp</span><span class="o">*</span><span class="n">xp</span> <span class="o">+</span> <span class="n">yp</span><span class="o">*</span><span class="n">yp</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">distortion</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">r2</span>  <span class="o">*</span> <span class="p">(</span><span class="n">l1</span> <span class="o">+</span> <span class="n">l2</span>  <span class="o">*</span> <span class="n">r2</span><span class="p">);</span>

    <span class="c1">// 计算最终的投影点位置</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">focal</span> <span class="o">=</span> <span class="n">camera</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
    <span class="n">T</span> <span class="n">predicted_x</span> <span class="o">=</span> <span class="n">focal</span> <span class="o">*</span> <span class="n">distortion</span> <span class="o">*</span> <span class="n">xp</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">predicted_y</span> <span class="o">=</span> <span class="n">focal</span> <span class="o">*</span> <span class="n">distortion</span> <span class="o">*</span> <span class="n">yp</span><span class="p">;</span>

    <span class="c1">// The error is the difference between the predicted and observed position.</span>
    <span class="c1">// 误差是预测值和观测值的区别</span>
    <span class="n">residuals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">predicted_x</span> <span class="o">-</span> <span class="n">T</span><span class="p">(</span><span class="n">observed_x</span><span class="p">);</span>
    <span class="n">residuals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">predicted_y</span> <span class="o">-</span> <span class="n">T</span><span class="p">(</span><span class="n">observed_y</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

   <span class="c1">// 隐藏代价函数对象的构造</span>
   <span class="k">static</span> <span class="n">ceres</span><span class="o">::</span><span class="n">CostFunction</span><span class="o">*</span> <span class="n">Create</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">observed_x</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="kt">double</span> <span class="n">observed_y</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">return</span> <span class="p">(</span><span class="k">new</span> <span class="n">ceres</span><span class="o">::</span><span class="n">AutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">SnavelyReprojectionError</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span>
                 <span class="k">new</span> <span class="n">SnavelyReprojectionError</span><span class="p">(</span><span class="n">observed_x</span><span class="p">,</span> <span class="n">observed_y</span><span class="p">)));</span>
   <span class="p">}</span>

  <span class="kt">double</span> <span class="n">observed_x</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">observed_y</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>与之前的例子不同，这是一个非平凡函数，计算Jacobian会十分费力，自动微分使得过程简便很多。函数<code>AngleAxisRotatePoint()</code>和其他操作旋转的函数在<code>include/ceres/rotation.h</code>中。</p>
<p>给定了函数，BA问题可以按下面进行构造：</p>
<div class="codehilite"><pre><span></span><span class="n">ceres</span><span class="o">::</span><span class="n">Problem</span> <span class="n">problem</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bal_problem</span><span class="p">.</span><span class="n">num_observations</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ceres</span><span class="o">::</span><span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span> <span class="o">=</span>
      <span class="n">SnavelyReprojectionError</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span>
           <span class="n">bal_problem</span><span class="p">.</span><span class="n">observations</span><span class="p">()[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">0</span><span class="p">],</span>
           <span class="n">bal_problem</span><span class="p">.</span><span class="n">observations</span><span class="p">()[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
  <span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="n">cost_function</span><span class="p">,</span>
                           <span class="nb">NULL</span> <span class="cm">/* squared loss */</span><span class="p">,</span>
                           <span class="n">bal_problem</span><span class="p">.</span><span class="n">mutable_camera_for_observation</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                           <span class="n">bal_problem</span><span class="p">.</span><span class="n">mutable_point_for_observation</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<p>构造问题的方式与上面曲线拟合的例子相似。由于这是一个大的稀疏问题，求解的一种方式是设置<code>Solver::Options::linear_solver_type</code>为<code>SPARSE_NORMAL_CHOLESKY</code>并调用<code>Solve</code>。BA问题有一个特殊的稀疏结构，可以更高效的求解。Ceres提供了三种特定的求解器（基于Schur的求解器），示例代码使用了最简单的一种<code>DENSE_SCHUR</code>。</p>
<div class="codehilite"><pre><span></span><span class="n">ceres</span><span class="o">::</span><span class="n">Solver</span><span class="o">::</span><span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
<span class="n">options</span><span class="p">.</span><span class="n">linear_solver_type</span> <span class="o">=</span> <span class="n">ceres</span><span class="o">::</span><span class="n">DENSE_SCHUR</span><span class="p">;</span>
<span class="n">options</span><span class="p">.</span><span class="n">minimizer_progress_to_stdout</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">ceres</span><span class="o">::</span><span class="n">Solver</span><span class="o">::</span><span class="n">Summary</span> <span class="n">summary</span><span class="p">;</span>
<span class="n">ceres</span><span class="o">::</span><span class="n">Solve</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">problem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">summary</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">summary</span><span class="p">.</span><span class="n">FullReport</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>


<h2 id="_8"><a name="user-content-_8" href="#_8" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>通用无约束优化</h2>
<p>尽管Ceres被设计为求解非线性最小二乘问题，不过Ceres也包含一些常用的无约束优化问题。<code>GradientProblem</code>和<code>GradientProblemSolver</code>是一个求解器。</p>
<h3 id="rosenbrock"><a name="user-content-rosenbrock" href="#rosenbrock" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Rosenbrock函数</h3>
<p>考虑Rosenbrock函数，定义一个<code>FirstOrderFunction</code>借口，负责计算对象函数值和梯度。</p>
<p><div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Rosenbrock</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ceres</span><span class="o">::</span><span class="n">FirstOrderFunction</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Evaluate</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">parameters</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">*</span> <span class="n">cost</span><span class="p">,</span>
                        <span class="kt">double</span><span class="o">*</span> <span class="n">gradient</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

    <span class="n">cost</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gradient</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">gradient</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mf">200.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
      <span class="n">gradient</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">200.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">int</span> <span class="n">NumParameters</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<br />
然后构造<code>GradientProblem</code>对象并调用<code>Solve()</code>。</p>
<div class="codehilite"><pre><span></span><span class="kt">double</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">};</span>

<span class="n">ceres</span><span class="o">::</span><span class="n">GradientProblem</span> <span class="n">problem</span><span class="p">(</span><span class="k">new</span> <span class="n">Rosenbrock</span><span class="p">());</span>

<span class="n">ceres</span><span class="o">::</span><span class="n">GradientProblemSolver</span><span class="o">::</span><span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
<span class="n">options</span><span class="p">.</span><span class="n">minimizer_progress_to_stdout</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">ceres</span><span class="o">::</span><span class="n">GradientProblemSolver</span><span class="o">::</span><span class="n">Summary</span> <span class="n">summary</span><span class="p">;</span>
<span class="n">ceres</span><span class="o">::</span><span class="n">Solve</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">problem</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">summary</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">summary</span><span class="p">.</span><span class="n">FullReport</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>


  <p style="text-align: right; color: gray;"><br>2018-08-16 15:39:24</p>
        </div>
      </div>
      <footer>
        <p>
          JinJay's blog<a href="https://github.com/ijinjay" target="_blank">@JinJay</a>.
        </p>
        <script src="http://s4.cnzz.com/z_stat.php?id=1253269299&amp;web_id=1253269299" language="JavaScript"></script>
      </footer>
      </main>
    </div>
  </body>
</html>

